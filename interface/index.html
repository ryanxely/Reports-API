<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Ã‰diteur de Rapport â€” Mini App</title>

    <!-- Quill.js (Ã©diteur de texte enrichi) -->
    <link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>

    <link rel="stylesheet" href="styles/index.css">
</head>

<body>
    <div class="container">
        <div class="header-nav">
            <h2>ğŸ“ Nouveau rapport</h2>
            <div class="header-nav-links">
                <a href="view.html" class="view-reports-link">ğŸ“‹ Voir mes rapports</a>
                <a href="profile.html" class="view-reports-link">ğŸ‘¤ Profil</a>
                <button class="logout-btn" onclick="handleLogout()">ğŸ”— DÃ©connexion</button>
            </div>
        </div>

        <div class="title-card">
            <input id="title" placeholder="Titre du rapport" />
        </div>

        <div class="form-row">
            <label for="fileInput">ğŸ“ PiÃ¨ces jointes</label>
            <div class="file-upload-area" onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput"
                    accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.zip,.rar" multiple />
                <div class="file-upload-text">
                    <strong>Cliquez pour sÃ©lectionner</strong> ou glissez-dÃ©posez vos fichiers<br>
                    <small>Images, vidÃ©os, audio, documents (PDF, Word, Excel, etc.)</small>
                </div>
            </div>
            <div id="preview" class="preview"></div>
        </div>

        <div class="editor-card">
            <label for="editor">âœï¸ Contenu</label>
            <div id="editor"></div>
        </div>

        <div class="actions">
            <button id="submitBtn" class="primary">âœ“ Envoyer le rapport</button>
            <button id="previewBtn" class="secondary" style="display: none;">ğŸ‘ AperÃ§u</button>
        </div>

        <div class="status" id="status"></div>
        <div class="meta" id="meta"></div>
    </div>

    <!-- Script Telegram Web App -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script src="config.js"></script>
    <script src="js/storage.js"></script>
    <script src="js/api.js"></script>
    <script src="js/dom-helpers.js"></script>
    <script>
        // ===== VÃ©rification d'authentification =====
        requireAuth();

        // Gestionnaire de dÃ©connexion
        window.handleLogout = function () {
            logout();
            window.location.href = 'login.html';
        };

        // ===== Configuration de l'application =====
        const REPORTS_API_URL = getApiUrl(CONFIG.REPORTS_ADD);

        // ===== Initialisation de l'Ã©diteur Quill =====
        const quill = new Quill('#editor', {
            theme: 'snow',
            placeholder: 'RÃ©digez votre rapport ici...'
        });

        // ===== Telegram WebApp =====
        const tg = window.Telegram.WebApp;
        tg.expand();

        const statusEl = document.getElementById("status");
        const metaEl = document.getElementById("meta");
        const submitBtn = document.getElementById("submitBtn");
        const previewBtn = document.getElementById("previewBtn");
        const fileInput = document.getElementById('fileInput');
        const previewEl = document.getElementById('preview');

        let selectedFilesData = [];

        // ===== Utilitaires =====

        /**
         * Convertit une URL de donnÃ©es en Blob
         */
        function dataURLToBlob(dataURL) {
            const parts = dataURL.split(',');
            const mime = parts[0].match(/:(.*?);/)[1];
            const bstr = atob(parts[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], { type: mime });
        }

        /**
         * Formate la taille du fichier
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Octets';
            const k = 1024;
            const sizes = ['Octets', 'Ko', 'Mo', 'Go'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        /**
         * Obtient l'icÃ´ne pour un type de fichier
         */
        function getFileIcon(type) {
            if (type.startsWith('image/')) return 'ğŸ–¼ï¸';
            if (type.startsWith('video/')) return 'ğŸ¥';
            if (type.startsWith('audio/')) return 'ğŸµ';
            if (type.includes('pdf')) return 'ğŸ“„';
            if (type.includes('word') || type.includes('document')) return 'ğŸ“';
            if (type.includes('sheet') || type.includes('excel')) return 'ğŸ“Š';
            if (type.includes('presentation') || type.includes('powerpoint')) return 'ğŸ“½ï¸';
            if (type.includes('zip') || type.includes('rar') || type.includes('compressed')) return 'ğŸ—œï¸';
            if (type.includes('text')) return 'ğŸ“ƒ';
            return 'ğŸ“';
        }

        /**
         * CrÃ©e un Ã©lÃ©ment de prÃ©visualisation pour un fichier
         */
        function createPreviewElement(fileData, index) {
            const item = document.createElement('div');
            item.className = 'preview-item';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'preview-item-remove';
            removeBtn.innerHTML = 'Ã—';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeFile(index);
            };

            if (fileData.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = fileData.data;
                img.alt = fileData.name;
                item.appendChild(img);
            } else if (fileData.type.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = fileData.data;
                video.controls = false;
                video.muted = true;
                item.appendChild(video);
            } else {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'preview-item-file';

                const icon = document.createElement('div');
                icon.className = 'preview-item-file-icon';
                icon.textContent = getFileIcon(fileData.type);

                const name = document.createElement('div');
                name.className = 'preview-item-file-name';
                name.textContent = fileData.name;

                fileDiv.appendChild(icon);
                fileDiv.appendChild(name);
                item.appendChild(fileDiv);
            }

            const info = document.createElement('div');
            info.className = 'preview-item-info';
            info.textContent = formatFileSize(fileData.size);
            item.appendChild(info);

            item.appendChild(removeBtn);

            return item;
        }

        /**
         * Supprime un fichier de la sÃ©lection
         */
        function removeFile(index) {
            selectedFilesData.splice(index, 1);
            updatePreview();
        }

        /**
         * Met Ã  jour l'affichage de la prÃ©visualisation
         */
        function updatePreview() {
            previewEl.innerHTML = '';
            selectedFilesData.forEach((fileData, index) => {
                const element = createPreviewElement(fileData, index);
                previewEl.appendChild(element);
            });
        }

        /**
         * Lit les fichiers sÃ©lectionnÃ©s
         */
        async function readFiles(files) {
            const readers = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve({
                        name: file.name,
                        type: file.type,
                        data: reader.result,
                        size: file.size
                    });
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            });

            try {
                const filesData = await Promise.all(readers);
                // Ajouter les nouveaux fichiers aux fichiers existants
                selectedFilesData.push(...filesData);
                updatePreview();
            } catch (err) {
                console.error('Erreur lors de la lecture des fichiers:', err);
                showStatus('Erreur lors de la lecture des fichiers', true);
            }
        }

        /**
         * Affiche un message de statut
         */
        function showStatus(message, isError = false) {
            statusEl.textContent = message;
            statusEl.className = 'status show';
            if (isError) {
                statusEl.classList.add('error');
            } else {
                statusEl.classList.add('success');
            }

            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 5000);
        }

        // ===== Gestionnaires d'Ã©vÃ©nements =====

        // Gestion du changement de fichier
        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                readFiles(e.target.files);
                // RÃ©initialiser l'input pour permettre la sÃ©lection du mÃªme fichier
                e.target.value = '';
            }
        });

        // Gestion du glisser-dÃ©poser
        const uploadArea = document.querySelector('.file-upload-area');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#138496';
            uploadArea.style.background = '#e6fcff';
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#17a2b8';
            uploadArea.style.background = '#f0fdff';
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#17a2b8';
            uploadArea.style.background = '#f0fdff';

            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                readFiles(e.dataTransfer.files);
            }
        });

        // Afficher les informations utilisateur
        const userProfile = getUserProfile();
        displayUserInfo(metaEl, userProfile, tg.initDataUnsafe?.user);

        // ===== Soumission du rapport =====
        async function submitReport() {
            const title = document.getElementById("title").value.trim();
            const content_html = quill.root.innerHTML;

            if (!title && quill.getLength() <= 1) {
                showStatus("Veuillez entrer un titre ou du contenu.", true);
                return;
            }

            // Construire FormData avec le contenu et les fichiers
            const formData = new FormData();
            formData.append("title", title);
            formData.append("content_text", content_html);

            // Joindre les fichiers
            if (selectedFilesData && selectedFilesData.length > 0) {
                selectedFilesData.forEach((fd, i) => {
                    const blob = dataURLToBlob(fd.data);
                    formData.append(`files`, blob, fd.name);
                });
            }

            showStatus("Envoi du rapport au serveur...");

            try {
                // RÃ©soudre la clÃ© API
                const apiKey = getApiKey('reports');
                if (!apiKey) {
                    showStatus('ClÃ© API manquante. Veuillez vous connecter ou configurer la clÃ©.', true);
                    return;
                }

                // Construire les en-tÃªtes
                const headers = {
                    'accept': 'application/json',
                    'x-api-key': apiKey
                };

                // Inclure le token d'authentification si disponible
                const authToken = getAuthToken();
                if (authToken) headers['Authorization'] = 'Bearer ' + authToken;

                const res = await fetch(REPORTS_API_URL, {
                    method: "POST",
                    headers: headers,
                    body: formData
                });

                if (res.status === 401) {
                    showStatus('Session expirÃ©e. Redirection vers la connexion...', true);
                    handleSessionExpiry();
                    return;
                }

                if (!res.ok) {
                    const txt = await res.text();
                    throw new Error(`Erreur serveur ${res.status}: ${txt}`);
                }

                const json = await res.json();
                if (json && json.ok) {
                    showStatus("âœ… Rapport soumis avec succÃ¨s. ID: " + (json.report?.id || 'n/a'));

                    // RÃ©initialiser le formulaire
                    document.getElementById("title").value = "";
                    quill.setContents([]);
                    selectedFilesData = [];
                    updatePreview();

                    // Effacer les brouillons du localStorage
                    clearDraftData();

                    // Informer le bot
                    try {
                        tg.sendData(JSON.stringify({ type: "report_submitted", title, report: json.report }));
                    } catch (err) {
                        console.warn("sendData Ã©chouÃ©", err);
                    }
                } else {
                    throw new Error(json?.message || 'RÃ©ponse serveur inconnue');
                }
            } catch (err) {
                console.error(err);
                showStatus("âŒ Ã‰chec de la soumission du rapport: " + err.message, true);
            }
        }

        submitBtn.addEventListener("click", submitReport);

        // PrÃ©visualisation HTML
        previewBtn.addEventListener("click", () => {
            const html = quill.root.innerHTML;
            const win = window.open("", "_blank");
            win.document.write("<title>AperÃ§u</title>" + html);
            win.document.close();
        });

        // Sauvegarde automatique toutes les 10 secondes
        setInterval(() => {
            setDraftData(document.getElementById("title").value, quill.root.innerHTML);
        }, 10000);

        // Charger le brouillon s'il existe
        const draft = getDraftData();
        if (draft.title) document.getElementById("title").value = draft.title;
        if (draft.content) quill.root.innerHTML = draft.content;
    </script>
</body>

</html>